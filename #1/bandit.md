# Bandit

---

### Level 0
```bash
ssh bandit0@bandit.labs.overthewire.org -p 2220
```
위와 같이 입력 후 패스워드를 입력하여 접속한다.

---
### Level 1
`home` 디렉토리에 있는 `readme` 파일이 패스워드이다.

---
### Level 2
`-` 파일을 아래의 명령어로 읽는다.
```bash
cat < -
```

---
### Level 3
`spaces in this filename` 파일을 `cat` 명령어로 읽는다.  
(리눅스 터미널이나 윈도우 커맨드 모두 공백은 `'\ '` 형태로 처리하는 것으로 알고 있음)

---
### Level 4
`inhere` 디렉토리 내부에 `.hidden` 파일이 존재한다.  
`ls` 명령어의 `-a` 옵션을 통해 모든 파일을 볼 수 있다.

---
### Level 5
`file` 명령어를 통해 읽을 수 있는 파일 형식을 찾으려고 시도하였다. 하지만 파일 이름이 `-f`로 시작하여 옵션으로 인식하였다.
```bash
cat < [filename]
```
어쩔 수 없이 위와 같은 명령어로 하나씩 확인하였다.

---
### Level 6
크기가 1033인 파일을 찾기 위해 아래와 같은 명령어를 사용하였다.
```bash
find . -size 1033c
```
운이 좋게도 해당 조건의 파일이 단 하나만 존재하였다.

---
### Level 7
```bash
find / -user bandit7 -group bandit6 -size 33c
```
위의 명령어를 통하여 권한 오류가 발생하지 않는 `bandit7.password` 파일을 발견하였다.

---
### Level 8
```bash
grep -w 'millionth' data.txt
```
파일 내에 해당 문자열이 있는 줄을 출력하도록 하였다.

---
### Level 9
```bash
sort data.txt | uniq -c
```
`uniq` 명령어의 경우 중복된 문자열이더라도 분산되어 있는 경우, 중복 체크가 불가능하다.  
따라서 먼저 `sort` 명령어로 정렬한 후에 `uniq` 명령어의 `-c` 옵션으로 중복된 문자열의 수를 함께 출력하였다.

---
### Level 10
```bash
strings data.txt | grep =
```
바이너리 형식의 파일을 문자열로 변환한 다음에 `=`이 들어가는 문자열을 확인하였다.

---
### Level 11
```bash
base64 --decode data.txt
```
base64로 인코딩 되어 있는 파일을 다시 디코딩하여 패스워드를 추출하였다.​

---
### Level 12
```bash
cat data.txt | tr a-zA-Z n-za-mN-ZA-M
```
텍스트를 정규식 변환을 통하여 rot13 처리하였다.

---
### Level 13
`data.txt` 파일을 확인해보면 `hexdump` 형태의 텍스트 파일임을 알 수 있다.
```bash
xxd -r data.txt [filename]
```
위의 명령어를 사용하여 `hexdump`를 바이너리 형태로 변환한다.  
여러번 압축되어 있기 때문에 `file` 명령어를 사용하여 압축 형태를 확인한 후,
파일 확장자를 바꿔주고 압축을 풀어준다.  
그리고 텍스트 파일이 나올 때까지 반복한다.

---
### Level 14*
```bash
ssh -i sshkey.private bandit14@localhost
```
처음에 호스트를 `bandit.labs.overthewire.org`로 접속하려고 했는데 Timeout Error가 발생하였다. 생각해보니까 문제에 제시된 `localhost`가 내 호스트가 아닌 `bandit`을 의미하고 있다는 것을 깨달았다.

---
### Level 15
```bash
nc localhost 30000
```
30000 포트로 연결하여 `Level 14`의 패스워드를 요청으로 보내 응답을 받는다.

---
### Level 16
```bash
openssl s_client -connect localhost:30001
```
SSL 인증서를 사용하기 위해 해당 명령어를 사용하여 30001 포트에 연결한 후, `Level 15`의 패스워드를 요청으로 보내 응답을 받는다.

---
### Level 17*
```bash
nmap -p31000-32000 localhost
```
`nmap` 명령어를 통해 해당 범위의 포트를 스캔하였다.  
두 개의 포트가 열려있는 것을 확인하고 SSL 인증서로 연결을 시도하였다.  
둘 중 하나에서 `Level 16`의 패스워드로 요청을 보내 `ssl private key`를 응답으로 받았다.  
`/tmp`에 디렉토리 생성하고 `private key`를 복사하여 파일로 만든 후, SSH 접속을 시도하였다.  
권한 경고가 발생하는 것을 보고 `chmod 600` 명령어로 권한을 제한하였다.  
`bandit17@localhost`로 SSH 접속하고 `/etc/bandit_pass`에서 패스워드를 확인하였다.

---
### Level 18
`diff` 명령어를 사용하여 두 파일 사이에 유일하게 변경된 패스워드를 찾는다.

---
### Level 19*
`.bashrc`를 무시하기 위해 `bash --norc` 옵션을 추가하여 SSH 접속을 시도했지만 서버 반응이 없었다.  
명령어 매뉴얼을 먼저 정독하는 것이 먼저였지만 너무 화가 나서(...) 풀이를 검색하였다.  
`ssh` 옵션을 보니 `-t` 옵션이 강제로 쉘 위치를 지정할 수 있는 것 같았다.  
`/bin/sh` 위치로 지정하고 SSH 접속을 하고 나서야 `readme` 파일을 읽을 수 있었다.

---
### Level 20*
영어 해석 엉뚱하게 해놓고 짜증내다가 풀이 보고 아차 했던 문제(...)  
실행파일이길래 실행을 해봤더니 출력 결과가 사실 실행 예시를 줬던 것이었다.  
(문제에서 인자 없이 실행을 시켜보라는 말이 있었는데 대체 어떻게 이해했던 건지 참..)  
인자로 `id`를 넣으니까 `euid`가 `bandit20` 이었다.(uid와 euid의 차이는?)  
`id` 대신에 `cat /etc/bandit_pass/bandit20`을 통해 패스워드를 읽었다.

---
### Level 21*
연결을 어떻게 하라는 건지 이해를 못해서 멍때린 문제(...)  
포트번호를 인자로 입력하면 연결이 이루어지고 `Level 20`의 패스워드를 전송하면 `Level 21`의 패스워드를 응답으로 받는다.  
그래서 `nmap`으로 `localhost`에서 열려있는 포트를 찾아서 연결을 시도했는데, 3개 중에서 2개는 응답이 없었고 남은 하나인 ssh 22번 포트에 연결을 해봤는데 오류 출력하고 접속을 종료해버렸다.  
알고 보니 `nc`로 새로운 포트를 열어서 터미널 두 개로 연결하고 상호 통신을 해야했다.  
(아래에 `screen`이나 `tmux` 같은 다중 세션을 활용하는 명령어의 사용을 권장하는 이유가 있었다..)  
`nc`로 임의의 포트를 열어주고 `Level 20`의 패스워드를 넘긴 다음에, 새로운 터미널에서 주어진 파일로 열어둔 포트에 접속하여 넘겨 받은 패스워드와 일치함을 확인하면 `Level 21`의 패스워드를 반환해준다.

---
### Level 22
`cron` : 시간 기반 작업 스케줄러  
제시된 폴더를 보면 특정 작업을 수행하는 파일들이 있다.  
`cronjob_bandit22` 파일을 보면 반복적으로 어떤 쉘 파일을 실행하는 것을 알 수 있다.
해당 쉘 파일의 내용을 확인해보면 특정 파일의 퍼미션을 변경하고 `Level 22`의 패스워드를 그 파일에 덮어 씌운다.  
그 파일의 내용을 확인하여 패스워드를 얻을 수 있었다.

---
### Level 23
`Level 22`와 동일하게 접근하였다.  
쉘 파일을 보면 로그인 계정을 가지고 md5로 암호화하여 로그인 계정의 패스워드를 그 md5 암호화 문자열 파일에 저장하는 것을 확인할 수 있다.  
구하고자 하는 계정은 `bandit23`으로, 쉘 코드에서 암호화 하는 부분을 복사한 후에 `$myname` 부분을 `bandit23`으로 바꿔 md5 암호화하고 `/tmp` 아래의 파일을 확인하면 패스워드를 획득할 수 있다.

---
### Level 24*
쉘 코드를 봤을 때 `/var/spool/$myname` 디렉토리로 이동하여 해당 디렉토리에 존재하는 모든 파일을 실행하고 제거하는 것을 알 수 있다.  
그래서 `bandit24` 디렉토리로 이동하여 쉘 코드를 작성하고자 하였다.  
여기서 접근을 잘못한 것이 접속한 계정은 `bandit23`인데 `bandit24`의 쉘을 따려고 하고 있었다.  
`Level 22`와 `Level 23`의 쉘 코드를 보면 패스워드를 특정 파일에 저장하는 것을 볼 수 있다.  
그래서 이와 비슷하게 특정 파일에 `bandit24`의 패스워드를 저장할 수 있도록 쉘 코드를 작성한다.  
그리고 권한을 상승시켜 정상적으로 실행될 수 있도록 한다.  
스케줄러가 1분마다 작동하도록 하기 때문에 잠시 후에 쉘 코드가 사라지고 어떤 파일이 생성되는 것을 확인한다.

---
### Level 25*
아직 `bash`가 생소하지만 억지로 직접 짜보려고 했다.  
`Level 24`의 패스워드 뒤에 4자리의 핀코드를 Brute Force Attack을 통해 `Level 25`의 패스워드를 얻고자 하였다.  
그래서 처음에는 패스워드에 핀코드를 계속 증가시켜 `nc` 명령어로 요청을 보내고 그 결과를 파일에 저장하고자 했다.  
그런데 반응이 없어서 결과 파일을 보니까 속도가 너무 느렸다.  
급하게 하려고 하니까 도저히 생각이 나지 않아서 다른 사람의 쉘 코드를 참고하였다.  
0부터 9999까지 패스워드 뒤에 붙여서 리스트를 만들고 그 리스트로 `nc`로 요청을 보냈다.  
결과를 확인해보니 Timeout 되고 도중에 끊긴 것을 확인할 수 있었다.  
그래서 반으로 나눠서 0-5000, 5001-9999로 두 번 시도하였다.  
`uniq` 명령어로 결과 파일을 확인해보니 패스워드를 획득할 수 있었다.

---
### Level 26*
당최 이해를 못하겠던 문제(...)  
`sshkey`가 있길래 SSH 접속을 시도했는데 접속하고 바로 종료시켜버렸다.  
`more` 명령어가 있어서 봤는데 도저히 이 문제 푸는 데 쓰일 거 같지는 않았다.  
`/etc/passwd` 파일을 확인해보면 `bandit26`에서 `/usr/bin/showtext`를 확인할 수 있었다.  
해당 파일을 열어보면 `text.txt`를 `more` 명령어로 실행하는 것을 확인할 수 있었다.  
창을 작게 만들고 다시 SSH 접속을 해보면 `more` 명령어가 작동하여 바로 종료되지 않는다.  
여기서 v를 눌러 vi 에디터로 이동하고 `:set shell=/bin/bash`로 쉘을 바꿔버린 후 `:shell`로 쉘을 실행한다.

---
### Level 27
`bandit26`의 연장선이자, `Level 20`과 동일한 풀이

---
### Level 28*
(퍼미션 에러 뜨면 권한 좀 잘 확인하자 ㅂㄷㅂㄷ)  
`home` 디렉토리에서 왜 `clone` 안되는거야 하면서 부들부들 거렸다..  
`/tmp`에 임시 디렉토리 만들어서 `clone` 한 다음에 `repo` 디렉토리에서 `README` 파일을 확인하였다.

---
### Level 29*
(교훈: 로그를 잘 확인하자)  
이전 문제와는 다르게 `md` 파일이 존재하고, 내용은 `username`과 `password`가 존재하였다.  
git을 통해 버전 관리를 하기 때문에 변경 전의 내용을 알기 위해 로그를 확인한다.  
```bash
git log -p
```
커밋 로그를 확인하기 위해 위와 같은 명령어를 사용하였다.

---
### Level 30*
커밋 로그를 확인해봐도 패스워드 변경 이력은 없었다.  
해당 브랜치에 존재하지 않는 것으로 판단하고 다른 브랜치를 검색하였다.  
그중 `dev`로 이동하여 다시 `md` 파일을 확인해보면 패스워드를 획득할 수 있다.

---
### Level 31*
git 문제 처음 풀 때 `.git` 디렉토리에 있는 모든 것을 확인해봤는데, git을 써본 것도 오래 되었고 원래도 잘 못써서(...) 구성을 이해 못하고 넘어갔다.  
`md` 파일에는 단서가 하나도 없어서 너무 막막했다.  
git은 sha값을 찾을 때 우선 `refs`에서 찾고 없는 경우에 `packed-refs`에서 찾는다고 한다.  
`packed-refs` 값을 확인해보면 브랜치 같은 것을 확인할 수 있었다.  
```bash
git show
```
위의 명령어를 사용하여 `secret`의 정보를 확인하여 패스워드를 획득할 수 있었다.

---
### Level 32*
`md` 파일을 확인했을 때 원격 저장소에 어떤 조건을 가진 파일을 push해야 하는 것으로 보였다.  
일단 해당 조건의 파일을 만들고 commit 이전 단계까지는 꾸역꾸역 가긴 했다.  
그리고 그냥 commit 하고 push 해보니까 진행상황 출력에서 패스워드를 확인할 수 있었다.

---
### Level 33*
(uppercase shell... 이런 쉘이 있을 수 있나...)  
쉘에서 `$0`는 인자를 의미하는 거라고는 하는데 `uppershell`에서 왜 `bash`로 넘어가는지는 아직 잘 모르겠다.  
`bash`가 열리고 `bandit_pass`에서 패스워드를 확인하였다.  
쉘에 대한 이해가 많이 필요한 문제라고 생각한다.
