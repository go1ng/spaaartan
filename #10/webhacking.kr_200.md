# webhacking.kr (200 pts)
_**old-33**, **SQL** 문서 분리_

## old-01
화면에는 레벨과 소스 코드를 확인할 수 있는 링크가 있다. 소스 코드를 확인해보니 페이지가 로딩될 때 `user_lv`이라는 이름으로 1이 할당된 쿠키가 설정된다.

```php
<?php
  if(!is_numeric($_COOKIE['user_lv'])) $_COOKIE['user_lv']=1;
  if($_COOKIE['user_lv']>=6) $_COOKIE['user_lv']=1;
  if($_COOKIE['user_lv']>5) solve(1);
  echo "<br>level : {$_COOKIE['user_lv']}";
?>
```
위의 PHP 코드를 보면 `user_lv`의 값이 숫자가 아니거나 6 이상일 경우에는 1로 초기화되고, 5를 초과할 경우에 `solve()` 함수가 작동하여 문제가 풀릴 것으로 보인다. 그렇다는 것은 `5<user_lv<=6` 범위의 실수를 입력하면 문제를 해결할 수 있다.

---

## old-20
닉네임과 코멘트, 그리고 CAPTCHA를 입력할 수 있는 폼이 있다. 그리고 2초의 시간 제한이 있다는 것을 알려주고 있다. 입력창을 모두 채우고 Submit 버튼을 눌러보면 너무 느리다는 반환값을 받는다. 따라서 이 문제는 페이지가 로딩된 후 2초 내에 CAPTCHA까지 완벽하게 입력하여 요청을 보내야 풀릴 것으로 보인다.

```js
function ck(){
  if(lv5frm.id.value=="") { lv5frm.id.focus(); return; }
  if(lv5frm.cmt.value=="") { lv5frm.cmt.focus(); return; }
  if(lv5frm.captcha.value=="") { lv5frm.captcha.focus(); return; }
  if(lv5frm.captcha.value!=lv5frm.captcha_.value) { lv5frm.captcha.focus(); return; }
  lv5frm.submit();
}
```
페이지 소스 코드를 확인해보면 위와 같은 스크립트가 존재한다. Submit 버튼을 눌렀을 때 작동되는 스크립트임을 확인할 수 있다. 입력창이 공백일 경우에는 해당 부분으로 커서가 이동하고 요청이 전송되지 않는다. 2초 안에 CAPTCHA를 직접 입력할 수는 없기 때문에 스크립트를 수정하기로 하였다.

if문을 모두 삭제하여 `id`와 `cmt`의 값을 임의의 값으로 채우고, `captcha`의 값을 페이지 로딩 시에 생성된 값으로 할당해주고 나서 submit을 하도록 수정하였다. 아래와 같이 작성된 스크립트를 페이지가 로딩된 후 2초 내로 콘솔에 입력하여 문제를 해결할 수 있었다.

```js
lv5frm.id.value = "admin";
lv5frm.cmt.value = "hello";
lv5frm.captcha.value = lv5frm.captcha_.value;
lv5frm.submit();
```

---

## old-23
입력창이 하나 있고, `<script>alert(1);</script>`를 삽입하는 것이 목표이다. 저 스크립트를 입력해보면 'no hack' 이라고 떠서 필터링이 어떻게 되어 있는지 확인해보려고 이런저런 값을 넣어봤다. 숫자나 특수문자는 정상적으로 출력이 되고 알파벳은 두 글자 이상 붙어 있지만 않으면 정상적으로 출력되는 것을 확인하였다.

먼저 인코딩하여 우회하는 방법을 시도해봤다. URL 인코딩의 경우에는 필터링이 되었고, HTML 인코딩 같은 경우에는 페이지에 스크립트 구문이 출력은 되지만 작동하지는 않았다. Hex 인코딩도 시도해봤지만 출력값을 보니 스크립트로 변환되지는 않았다.

다음으로는 알파벳이 서로 붙어 있지만 않으면 필터링 되지 않기 때문에 글자들을 모두 끊어보기로 했다. `%20`이나 `%0a` 같은 공백 문자를 넣어봤을 때 문자열이 출력되기는 했지만 스크립트가 작동하지는 않았다. 그래서 다른 방법을 찾아야겠다고 생각하고 필터링 우회 방법을 검색하였다.

위에서 공백 문자가 의미 없는 것 같기도 했고, `%00` 같은 널 바이트를 넣으면 문자열이 잘려서 출력될 것 같아서 시도해보지는 않았다. 하지만 아무리 찾아봐도 문자열을 끊어주는 방법 밖에 없을 것 같아서 널 바이트를 넣어보기로 했다. 임의의 알파벳 문자열을 `%00`으로 다 끊어서 입력해보니 정상적으로 출력되는 것을 볼 수 있었다. 그래서 `<script>`를 시도해봤는데, 페이지의 모든 요소가 사라지는 것을 보고 태그도 정상적으로 작동될 것으로 예상하였다. 스크립트 태그의 알파벳을 모두 `%00`으로 끊어서 입력하였더니 `alert(1)`가 작동되었고, 그렇게 문제를 해결할 수 있었다.

---

## old-36
> While editing index.php file using vi editor in the current directory, a power outage caused the source code to disappear. 
> Please help me recover.

현재 디렉토리에서 vi 에디터를 사용하여 `index.php`를 작성하다가 정전이 나서 사라진 소스 코드를 복구해달라는 내용이다. 이 문제에서는 vi 에디터가 힌트가 될 것으로 보인다.

구글에 vi 에디터의 비정상 종료와 관련한 내용을 검색해보았다. vi 에디터는 작업이 비정상적으로 종료되었을 때 `.[filename].swp`와 같이 `.swp` 확장자를 가진 스왑 파일을 생성한다고 한다. 그래서 `index.php`의 스왑 파일을 확인하기 위하여 URL에 `.index.php.swp`로 접근해봤더니 스왑 파일을 다운로드 받을 수 있었다. 파일을 숨김 파일로 만들어주기 위해 앞에 `.`을 붙여주었다.

vi 에디터에서 스왑 파일을 복구하기 위해서는 `-r` 옵션을 사용해야 한다. 터미널에서 아래와 같이 명령어를 입력해주면 스왑 파일로부터 파일이 복구되는 것을 확인할 수 있다.

```bash
$ vi -r index.php
```
복구된 파일을 확인해보면 플래그가 존재하고, 이것을 인증하여 문제를 해결하였다.

---

## old-42
파일 2개를 다운로드 할 수 있는 테이블이 존재한다. 플래그로 예상되는 `flag.docx` 파일의 다운로드 링크를 누르면 접근 거부 경고가 뜬다. 남은 `test.txt` 파일은 정상적으로 다운로드가 가능하다. 해당 파일의 내용은 의미있어 보이지 않았다.

페이지 소스 코드를 확인해봤다. `flag.docx` 파일의 다운로드 링크는 `alert()`를 띄워주는 JavaScript 코드로 작성되어 있었다. 반면에 `test.txt` 파일의 링크는 누르면 파일을 다운로드 할 수 있도록 특정한 값이 `down` 이라는 변수로 넘겨져 경로가 이동되는 구조였다. 그 값이 base64 형태로 예상되어 디코딩을 해보니 `test.txt`라는 값이 나왔다.

`flag.docx`를 base64로 인코딩하고 `down`의 값으로 넘겨 요청을 보내니까 해당 파일을 다운로드 받을 수 있었고, 파일 속의 플래그를 인증하여 문제를 해결하였다.